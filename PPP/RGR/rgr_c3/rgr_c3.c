/*** Програма до розрахунково-графічної роботи (стенд EV8031) *****
 *** Працюємо з інкрементальним енкодером ***
 *** При кожному повороті енкодера (один тік) за годинниковою стрілкою
 *** виведене на лінійку світлодіодів значення збільшується на 1, а
 *** при кожному повороті енкодера (один тік) проти годинникової стрілки
 *** виведене на лінійку світлодіодів значення зменшується на 1
 *** при натисканні на інкрементальний енкодер як на кнопку,
 *** світлодіодний індикатор повністю гасне ***/

#define F_CPU 7372800L //задаємо частоту кварцу (7,3728 МГц)

#include <avr/io.h>
#include <avr/iom8515.h>
#include <util/delay.h>
#include <avr/interrupt.h>

#define led_line 0xA006 //адреса лінійки світлодіодів в стенді

//регістр стану напівпровідникового світлодіода
volatile unsigned char diode;
//регістр тимчасового зберігання
volatile unsigned char temp;
//лічильник кількості імпульсів, одержаних від енкодера
//volatile unsigned char counter;
int counter = 0;
//регістр, який зберігає попередній стан інкрементального енкодера
volatile unsigned char last_state;
//регістр, який зберігає наступний стан інкрементального енкодера
volatile unsigned char next_state;

volatile unsigned char clock = 0b10000000;
volatile unsigned char conterclock = 0b00010000;
volatile unsigned int data = 0;
volatile unsigned char timer = 0;


 volatile unsigned int dot = 0b11111111;



ISR (TIMER1_COMPA_vect){
	timer = 1;
}

int main(void) {
    ACSR = 1 << ACD;    //відключення живлення аналогового компаратора
    MCUCR = 1 << SRE;    //дозволяємо роботу із зовнішньою пам'яттю

    TIMSK = 1 << OCIE1A;
    OCR1A = 0x0399;	//завантажуємо в регістрову пару OCR1AH:OCR1AL число 0x707F
				//або 28799, тобто задаємо значення, при досягненні якого
				//таймер/лічильник T1 згенерує переривання по співпадінню А
    SFIOR = 1 << PSR10;	//скидаємо переддільник,
					//фактично в цей момент відбувається початок відліку
    TCCR1A = 0x00;
    TCCR1B = 1 << WGM12 | 1 << CS11;

    //Оголошуємо допоміжний вказівник для звернення до світлодіодної лінійки
    volatile unsigned char *p = (unsigned char *) led_line; //встановлюємо вказівник p на адресу лінійки світлодіодів в стенді

    diode = 0x00;    //очищаємо регістр стану лінійки светодіов (гасимо все)
    counter = 0x00;    //очищаємо регістр лічби імпульсів, що надходять від енкодера

    last_state = PINB; //читаємо поточний стан каналів енкодера
    last_state &= 0b1001000; //визначаємо стан бітів порту, що відповідають за поточний стан енкодера
    //вважаємо, що в початковому стані енкодер ніхто не чіпав, тобто
    //в кожному з його каналів (канал B - PB4; канал A - PB7) утримується "0"

   
    diode = dot ^ (dot >> 1);
    *p = diode;
	
    sei();


    //Переходимо в нескінченний цикл опитування стану енкодера
    while (1) {
		if (timer == 1) {
	        //_delay_ms(1); //викликаємо затримку, щоб не читати стани енкодера занадто часто
	        next_state = PINB; //читаємо поточний стан каналів енкодера
	        next_state &= 0b10010000; //отримуємо стан бітів порту, що відповідають за поточний стан енкодера

	        if (next_state != last_state) { //якщо стан енкодера змінився
	            if (last_state == 0x00) { //якщо в каналі В енкодера не було "0" і в каналі А теж не було "0"
	                if (next_state == clock) { // якщо в каналі A енкодера стала "1", а в каналі B залишився "0"
	                    counter++; //збільшуємо значення лічильника кількості імпульсів, одержуваних від енкодера

	                    if (counter >= 2) {
	                        counter = 0;
	                        data++;
	                    }
	                } else if (next_state == conterclock) { //якщо в каналіA енкодера залишився "0", а в каналі B стала "1"
	                    counter--; //зменшення значення лічильника кількості імпульсів, одержуваних від енкодера

	                    if (counter <= -4) {
	                        counter = 0;
	                        data--;
	                    }
	                }
	            }
	        }

	        temp = PINB; //читаємо поточний стан каналів енкодера
	        temp &= 0b00100000; //отримуємо стан біту порту, що відповідає за натискання енкодера як кнопки

	        if (temp == 0x00) { //якщо енкодер натиснуто як кнопку, то обнуляємо стан діодів
	            counter = 0; //власне, скидання стану енкодера
	            data = 15;
	        }

	        // diode = counter; //оновлюємо вміст змінної стану світлодіодної лінійки
	        diode = data ^ (data >> 1);
			//diode = data;
	        *p = diode; //оновлюємо стан індикатора
	        last_state = next_state; //підготовка до наступної ітерації опитування стану енкодера
	        //присвоюємо попередньому стану енкодера його поточний стан

			timer = 0;
		}
    }
    return 0;
}
