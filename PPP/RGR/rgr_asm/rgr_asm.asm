;*** Програма до розрахунково-графічної роботи (стенд EV8031) *****
;*** Працюємо з інкрементального енкодером ***
;*** При кожному повороті енкодера (один тік) за годинниковою стрілкою
;*** виведене на лінійку світлодіодів значення збільшується на 1, а
;*** при кожному повороті енкодера (один тік) проти годинникової стрілки
;*** виведене на лінійку світлодіодів значення зменшується на 1
;*** при натисканні на інкрементальний енкодер як на кнопку,
;*** світлодіодний індикатор повністю гасне

.include "m8515def.inc"	;підключення модуля контролера ATmega8515

;*** Призначення символічних імен регістрів ***

.def diode = r16	;регістр, який зберігає стан світлодіодним лінійки
.def temp = r17		;регістр тимчасового зберігання
.def encoder_data = r18	;лічильник імпульсів енкодера

;Регістр, що зберігає попередній стан інкрементального енкодера
.def last_encoder_state = r19
;Регістр, що зберігає наступний стан інкрементального енкодера
.def next_encoder_state = r20

.def encoder_counter_r = r21
.def encoder_counter_l = r22
.def data = r15

.def counter = r23		;лічильник циклу в підпрограмі генерації затримки
.def long_delay_low = r24	;молодший байт лічильника довгої затримки
.def long_delay_high = r25	;старший байт лічильника довгої затримки

;*** Призначення констант ***

.EQU led_line = 0xA006; адреса лінійки світлодіодів в стенді


;***** Початок програми *****

.CSEG		;визначаємо початок сегмента коду
.ORG 0x0000	;визначаємо адресу початку сегмента коду в пам'яті програм

;*** Таблиця векторів переривань контролера ***

	rjmp Init; вектор переривання по скиданню
	reti; rjmp EXT_INT0; IRQ0 Handler
	reti; rjmp EXT_INT1; IRQ1 Handler
	reti; rjmp TIM1_CAPT; Timer1 Capture Handler
	reti; rjmp TIM1_COMPA; Timer1 Compare A Handler
	reti; rjmp TIM1_COMPB; Timer1 Compare B Handler
	reti; rjmp TIM1_OVF; Timer1 Overflow Handler
	reti; rjmp TIM0_OVF; Timer0 Overflow Handler
	reti; rjmp SPI_STC; SPI Transfer Complete Handler
	reti; rjmp USART_RXC; USART RX Complete Handler
	reti; rjmp USART_UDRE; UDR0 Empty Handler
	reti; rjmp USART_TXC; USART TX Complete Handler
	reti; rjmp ANA_COMP; Analog Comparator Handler
	reti; rjmp EXT_INT2; IRQ2 Handler
	reti; rjmp TIM0_COMP; Timer0 Compare Handler
	reti; rjmp EE_RDY; EEPROM Ready Handler
	reti; rjmp SPM_RDY; Store Program memory Ready

;*** Початкова ініціалізація контролера ***

Init:
	ldi temp, low (RAMEND)
	out SPL, temp
	ldi temp, high (RAMEND)
	out SPH, temp	;установка SP на останню адресу в SRAM
	sbi ACSR, 7		;відключення живлення аналогового компаратора

	ldi temp, 0b10000000	;дозволяємо роботу із зовнішньою пам'яттю
	out MCUCR, temp

	;Встановлюємо вказівник Z на адресу лінійки світлодіодів в стенді
	ldi ZL, low (led_line)
	ldi ZH, high (led_line)

	clr diode	;очищаємо регістр стану світлодіодної лінійки (гасимо всі діоди)
	clr encoder_data	;очищаємо регістр лічби імпульсів, що надійшли з енкодера

	in last_encoder_state, PINB	;читаємо поточний стан каналів енкодера

;Отримуємо стан бітів порту, що відповідають за поточний стан енкодера
	andi last_encoder_state, 0b10010000

;Вважаємо, що в початковому стані енкодер ніхто не використовує, тобто
	;в кожному з його каналів (канал B - PB4; канал A - PB7) утримується "0"
	;*** Переходимо в нескінченний цикл опитування стану енкодера ***

;*** Налаштування переривань ***

	ldi temp, (1 << OCIE1A)	;записуємо маску в регістр temp
	out TIMSK, temp		;записуємо в регістр TIMSK (дозволяємо переривання
					;за збігом A таймера/лічильника T1)

;*** Налаштування та пуск таймера/лічильника T1 ***

;Завантажуємо в пару регістрів OCR1AH: OCR1AL число 0x707F (28799d), тобто задаємо
;значення, при досягненні якого таймером/лічильником T1 буде
;згенеровано переривання по співпадінню A
	ldi encoder_counter_r, 0b000000000
	ldi encoder_counter_r, 0b000000000
	ldi temp, 0x70
	out OCR1AH, temp
	ldi temp, 0x7F
	out OCR1AL, temp
	ldi temp, (1 << PSR10)	;скидаємо переддільник, записуючи 1 в біт PSR10,
	out SFIOR, temp		;фактично в цей момент відбувається початок відліку					

;Завантажуємо в пару регістрів TCCR1A: TCCR1B число 0x000C
	ldi temp, 0b00000000
	out TCCR1A, temp	;задаємо режим роботи CTC і власне запускаємо
	ldi temp, (1 << WGM12) | (1 << CS12)	;таймер/лічильник T1, переддільник встановлено на 256
	out TCCR1B, temp		;!у цьому місці саме відбувається пуск таймера, хоча переддільник вже працює!

;!!!Оскільки переддільник встановлено на 256, то безпосередньо на лічильний вхід модуля таймера/лічильника T1
;надходить частота 7.3728 МГц / 256 = 28800 Гц. Очевидно, що модуль лічби становить N = 28800
;Звідси легко бачити, що для генерації часового проміжку в 1 с необхідно в 16-розрядний регістр
;порівняння OCR1AH: OCR1AL записати значення (N-1) = 28799d або 0x707F (707Fh)!!!
;!!!Завжди слід записувати N-1, тому що лічильник починає рахувати із нульового стану !!!



	ldi diode, 0x80



;*** Дозволяємо роботу замаскованих переривань ***

	sei	;встановлюємо прапорець глобального дозволу переривань
		;працюватиме тільки переривання TIM1_COMPA),
		;тобто переривання по співпадінню A таймера/лічильника Т1

;*** Переходимо в нескінченний цикл, де очікуємо переривання від таймера
;(Раз на секунду) і змінюємо стан світлодіодів ***



Infinite_loop:; нескінченний цикл
	rcall long_delay	;викликаємо затримку, щоб не читати стан енкодера занадто часто
	rjmp Infinite_loop
	
;*** Підпрограма обробки переривання по співпадінню A таймера/лічильника T1
TIM1_COMPA:		;обробник зовнішнього переривання TIM1_COMPA (при вході I = 0)

	in next_encoder_state, PINB	;читаємо поточний стан каналів енкодера

;Отримуємо стан бітів порту, що відповідають за поточний стан енкодера
	andi next_encoder_state, 0b10010000

	cp next_encoder_state, last_encoder_state
	breq Next_iterate	;якщо стан енкодера не змінився - продовжуємо його читати

	cpi last_encoder_state, 0b00000000	;якщо в каналі В енкодера не було "0" і в каналі А теж не було "0"
	brne Next_iterate; переходимо до подальших дій

	cpi next_encoder_state, 0b00010000	;якщо в каналі A енкодера залишився "0", а в каналі B з'явилася "1", то енкодер повернули проти годинниковою стрілкою
	breq Dec_enc_counter		;переходимо до зменшення стану енкодера

	cpi next_encoder_state, 0b10000000	;якщо в каналі A енкодера з'явилася "1", а в каналі B залишився "0", то енкодер повернули за годинниковою стрілкою
	breq Incr_enc_counter		;переходимо до збільшення стану енкодера

	cpi next_encoder_state, 0b00100000
	breq Encoder_as_button

	rjmp Next_iterate	;якщо в жодному з каналів не стався фронт - йдемо далі
	reti	;повернення із переривання
		;при цьому автоматично встановлюється прапорець I
		;з метою подальшого дозволу переривань

;***** Кінець програми *****

Incr_enc_counter:
	inc encoder_counter_r
	ldi encoder_counter_l, 0b00000000

	cpi encoder_counter_r, 0b00000010	;якщо в каналі A енкодера з'явилася "1", а в каналі B залишився "0", то енкодер повернули за годинниковою стрілкою
	BRGE Incr_state

Dec_enc_counter:
	inc encoder_counter_l
	ldi encoder_counter_r, 0b00000000

	cpi encoder_counter_l, 0b00000100	;якщо в каналі A енкодера залишився "0", а в каналі B з'явилася "1", то енкодер повернули проти годинниковою стрілкою
	BRGE Decr_state		;переходимо до зменшення стану енкодера

Encoder_as_button:
	ldi encoder_counter_r, 0b00000000
	ldi encoder_counter_l, 0b00000000
	ldi encoder_data, 0b00001111

	rjmp Next_iterate	;якщо в жодному з каналів не стався фронт - йдемо далі

Incr_state:
	ldi encoder_counter_r, 0b00000000
	inc encoder_data	;інкремент кількості імпульсів, отриманих від енкодера

	rjmp Next_iterate	;переходимо до подальших дій

Decr_state:
	ldi encoder_counter_l, 0b00000000
	dec encoder_data	;декремент кількості імпульсів, отриманих від енкодера

Next_iterate:	;перехід на цю мітку здійсниться в будь-якому випадку!
	in temp, PINB	;читаємо поточний стан каналів енкодера

	;Отримуємо стан біта порту, що відповідає за натискання енкодера як кнопки
	andi temp, 0b00100000

	tst temp	;якщо енкодер натиснуто як кнопку, то обнуляємо лічильник імпульсів, отриманих від нього
	brne Led_action		;а якщо ні - йдемо далі
	clr encoder_data		;власне, скидання стану енкодера

Led_action:
	mov data, encoder_data
	mov temp, encoder_data
	lsr temp
	eor data, temp

	mov diode, data	;оновлюємо вміст регістра стану лінійки світлодіодів
	st Z, diode			;оновлюємо стан індикатора

	mov last_encoder_state, next_encoder_state	;підготовка до наступної ітерації опитування стану енкодера
	;Присвоюємо попереднього стану енкодера його поточний стан
	rjmp Infinite_loop

;*** Підпрограма довгою затримки ***

long_delay:
;* Якщо в регістрову пару завантажити число 9 (0009h), то затримка буде близько 976,5 мкс
;* Приблизна формула розрахунку коефіцієнта при кварці в 7.3728 МГц така:
;* 800 x коефіцієнт затримки/(7.3728 * 1 000 000) = необхідний час в с

	ldi long_delay_low, 0x09; завантаження в регістрову пару коефіцієнта затримки
	ldi long_delay_high, 0x00	;0009h - це буде затримка на 976,5 мкс

long_loop:	;тіло циклу займає 796 + 2 + 2 = 800 тактів

	rcall short_delay		;коротка затримка
	sbiw long_delay_high: long_delay_low, 0b00000001	;віднімання із пари числа 1 (декремент довгого лічильника)
	brne long_loop		;якщо не 0, повторити цикл

	ret 		;повернення в основну програму

;*** Підпрограма короткої затримки (потрібна для генерації довгих затримок) ***

short_delay:	;вся підпрограма займає рівно 796 тактів разом з rcall і ret

	nop
	ldi counter, 0xC5		;лічильник циклу
short_loop:
	nop
	dec counter
	brne short_loop	;команда розгалуження по прапору нуля (зациклення)
	ret			;повернення в основну програму

.EXIT; кінець програми
