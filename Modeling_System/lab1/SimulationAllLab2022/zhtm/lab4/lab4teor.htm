<html>

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<meta name=Generator content="Microsoft Word 15 (filtered)">
<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;}
@font-face
	{font-family:"MS Mincho";
	panose-1:2 2 6 9 4 2 5 8 3 4;}
@font-face
	{font-family:"Cambria Math";
	panose-1:2 4 5 3 5 4 6 3 2 4;}
@font-face
	{font-family:"\@MS Mincho";
	panose-1:2 2 6 9 4 2 5 8 3 4;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-indent:35.45pt;
	font-size:14.0pt;
	font-family:"Times New Roman",serif;}
h1
	{mso-style-name:"Заголовок 1\,Знак";
	mso-style-link:"Заголовок 1 Знак";
	margin-top:0cm;
	margin-right:39.7pt;
	margin-bottom:18.0pt;
	margin-left:148.95pt;
	text-align:center;
	text-indent:85.0pt;
	page-break-before:always;
	font-size:14.0pt;
	font-family:"Arial",sans-serif;
	color:maroon;
	text-transform:uppercase;}
h2
	{mso-style-link:"Заголовок 2 Знак";
	margin-top:18.0pt;
	margin-right:39.7pt;
	margin-bottom:12.0pt;
	margin-left:36.0pt;
	text-indent:0cm;
	page-break-after:avoid;
	font-size:14.0pt;
	font-family:"Arial",sans-serif;}
h3
	{mso-style-link:"Заголовок 3 Знак";
	margin-top:12.0pt;
	margin-right:39.7pt;
	margin-bottom:6.0pt;
	margin-left:164.2pt;
	text-indent:-110.2pt;
	page-break-after:avoid;
	font-size:14.0pt;
	font-family:"Arial",sans-serif;
	font-style:italic;}
h4
	{mso-style-link:"Заголовок 4 Знак1";
	margin-top:12.0pt;
	margin-right:39.7pt;
	margin-bottom:6.0pt;
	margin-left:32.4pt;
	text-indent:-32.4pt;
	page-break-after:avoid;
	font-size:12.0pt;
	font-family:"Arial",sans-serif;}
p.MsoBodyText, li.MsoBodyText, div.MsoBodyText
	{mso-style-link:"Основной текст Знак";
	margin-top:0cm;
	margin-right:0cm;
	margin-bottom:6.0pt;
	margin-left:0cm;
	text-align:justify;
	text-indent:35.45pt;
	font-size:14.0pt;
	font-family:"Times New Roman",serif;}
span.1
	{mso-style-name:"Заголовок 1 Знак";
	mso-style-link:"Заголовок 1\,Знак";
	font-family:"Arial",sans-serif;
	color:maroon;
	text-transform:uppercase;
	font-weight:bold;}
span.2
	{mso-style-name:"Заголовок 2 Знак";
	mso-style-link:"Заголовок 2";
	font-family:"Arial",sans-serif;
	font-weight:bold;}
span.3
	{mso-style-name:"Заголовок 3 Знак";
	mso-style-link:"Заголовок 3";
	font-family:"Arial",sans-serif;
	font-weight:bold;
	font-style:italic;}
span.4
	{mso-style-name:"Заголовок 4 Знак";
	font-family:"Calibri Light",sans-serif;
	color:#2E74B5;
	font-style:italic;}
span.41
	{mso-style-name:"Заголовок 4 Знак1";
	mso-style-link:"Заголовок 4";
	font-family:"Arial",sans-serif;
	font-weight:bold;}
p.a, li.a, div.a
	{mso-style-name:"Стиль для списка";
	margin-top:0cm;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:36.05pt;
	margin-bottom:.0001pt;
	text-align:justify;
	text-indent:-14.2pt;
	font-size:14.0pt;
	font-family:"Times New Roman",serif;}
p.a0, li.a0, div.a0
	{mso-style-name:"Стиль текста программ в рамке";
	mso-style-link:"Стиль текста программ в рамке Знак";
	margin-top:6.0pt;
	margin-right:0cm;
	margin-bottom:6.0pt;
	margin-left:0cm;
	border:none;
	padding:0cm;
	font-size:12.0pt;
	font-family:"Times New Roman",serif;}
p.a1, li.a1, div.a1
	{mso-style-name:СтильЗаголовкаЛистинга;
	margin-top:6.0pt;
	margin-right:0cm;
	margin-bottom:6.0pt;
	margin-left:0cm;
	text-align:justify;
	page-break-after:avoid;
	font-size:14.0pt;
	font-family:"Times New Roman",serif;}
p.410, li.410, div.410
	{mso-style-name:"Заголовок 4_1";
	margin-top:12.0pt;
	margin-right:39.7pt;
	margin-bottom:3.0pt;
	margin-left:39.7pt;
	page-break-after:avoid;
	font-size:14.0pt;
	font-family:"Arial",sans-serif;
	font-weight:bold;
	font-style:italic;}
p.a2, li.a2, div.a2
	{mso-style-name:Листинг;
	margin-top:6.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:0cm;
	margin-bottom:.0001pt;
	page-break-after:avoid;
	font-size:14.0pt;
	font-family:"Times New Roman",serif;}
span.a3
	{mso-style-name:"Стиль текста программ в рамке Знак";
	mso-style-link:"Стиль текста программ в рамке";
	font-family:"Times New Roman",serif;}
span.a4
	{mso-style-name:"Основной текст Знак";
	mso-style-link:"Основной текст";
	font-family:"Times New Roman",serif;}
.MsoChpDefault
	{font-family:"Calibri",sans-serif;}
.MsoPapDefault
	{margin-bottom:8.0pt;
	line-height:107%;}
@page WordSection1
	{size:595.3pt 841.9pt;
	margin:2.0cm 42.5pt 2.0cm 3.0cm;}
div.WordSection1
	{page:WordSection1;}
 /* List Definitions */
 ol
	{margin-bottom:0cm;}
ul
	{margin-bottom:0cm;}
-->
</style>

</head>

<body lang=UK>

<div class=WordSection1>

<h2 style='margin-left:65.2pt;text-indent:-1.0cm'><a name="_Toc484953435"></a><a
name="_Toc392262905">1.1  Короткі теоретичні відомості</a></h2>

<h3 style='margin-top:12.0pt;margin-right:39.7pt;margin-bottom:3.0pt;
margin-left:73.7pt;text-indent:-36.85pt'><a name="_Toc484953436"></a><a
name="_Toc392262906"></a><a name="_Toc182675004"><span lang=RU
style='font-style:normal'>1.1.1 </span>Особливості моделювання паралельних
процесів</a></h3>

<p class=MsoNormal>Розглянемо як приклад, поведінку обслуговуючого пристрою з
прикладу, що розглядався у попередній лабораторній роботі. </p>

<p class=MsoNormal>Правила дії цього об’єкту полягають у багаторазовому
повторенні наступних операцій</p>

<p class=a style='margin-left:2.0cm;text-indent:-17.0pt'><span
style='font-family:Symbol'>-<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Очікування на появу транзакції у черзі.</p>

<p class=a style='margin-left:2.0cm;text-indent:-17.0pt'><span
style='font-family:Symbol'>-<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Вилучення транзакції з черги.</p>

<p class=a style='margin-left:2.0cm;text-indent:-17.0pt'><span
style='font-family:Symbol'>-<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Затримка у часі , що імітує обробку транзакції.</p>

<p class=a style='margin-left:2.0cm;text-indent:-17.0pt'><span
style='font-family:Symbol'>-<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Перехід до першого пункту.</p>

<p class=MsoNormal>Аналізуючи правила дії, що описані вище, неважко побачити
важливу особливість цього алгоритму – періодичні зупинки виконання коду, або на
якийсь час, або до виконання умови.</p>

<p class=MsoNormal>Друга особливість цього алгоритму полягає у тому, що він має
виконуватися одночасно з правилами дії генератора транзакцій, які мають також затримки
у часі.</p>

<p class=MsoNormal>Правила дії мають бути перетворені у деякий код, що
виконується комп'ютером. Для того щоб реалізувати паралельне виконання коду та
забезпечити зупинки у процесі виконання коду, правила дій об’єктів можна
представити у вигляді потоків.</p>

<p class=MsoNormal>Мова програмування Java надає багато можливостей для
програмної реалізації розглянутих алгоритмів. Один із шляхів, який, можливо, не
є найпростішим, полягає у моделюванні в реальному часі. У цьому випадку
затримки у часі можна забезпечити за допомогою метода sleep(). Але недолік
такого способу полягає в тому, що імітаційна модель буде працювати з великою
кількістю зупинок, що призведе до уповільнення роботи програми. Тривалість
зупинок можна зменшити за рахунок зміни масштабу часу, але у цьому випадку затримки,
що імітують виконання завдань, будуть близькими за величиною до часу виконання
коду, що призведе до великих похибок.</p>

<p class=MsoNormal style='text-autospace:none'>Інший спосіб полягає в тому, що
затримки створюються в деякому віртуальному часі, який змінюється дискретно від
події до події, і ніяк не пов'язаний з реальним часом, і внаслідок цього не
залежить від часу виконання коду. Але для реалізації такого способу необхідно
мати об’єкт, який буде керувати цим віртуальним часом. Назвемо цей об’єкт
диспетчером. Диспетчер визначає час на підставі списку майбутніх подій. Цей
список уявляє собою колекцію, у якій знаходяться посилання на об'єкти, що
затримані на деякий час. Кожен з об’єктів у цьому списку знає час відновлення
своїх правил дії, і список впорядковано саме за цим атрибутом об’єкту. Об’єкти
самі заносять себе до цього списку перед тим як призупинитися.</p>

<p class=MsoNormal style='text-autospace:none'>Диспетчер активізується тоді,
коли припиняються правила дії об'єктів, якими він керує. Диспетчер вилучає з
управляючого списку об’єкт з найменшим часом відновлення правил дії і присвоює
віртуальному часу значення, що відповідає запланованому моменту відновлення
правил дії вилученого об’єкту. Тобто диспетчер, побачивши яким повинен бути
час, таким його і встановлює. Виходить, що об’єкти управляють часом, а не
навпаки, і час змінюється дискретно від події до події. Змінивши час, диспетчер
відновлює правила дії об’єкту, а сам призупиняється.</p>

<p class=MsoNormal style='text-autospace:none'>Окрім списку майбутніх подій
диспетчер має ще список об’єктів, правила дії яких зупинені до виконання деяких
умов. Так само як і у попередньому випадку, об’єкти знають, чого чекають і самі
заносять себе до цього списку перед зупинкою. Диспетчер переглядає цей список
кожного разу перед зміною модельного часу, і якщо якась умова виконується, то
правила дії відповідного об’єкту поновлюються без зміни часу.</p>

<h3 style='margin-top:12.0pt;margin-right:39.7pt;margin-bottom:3.0pt;
margin-left:73.7pt;text-indent:-36.85pt'><a name="_Toc484953437"></a><a
name="_Toc392262907"><span lang=RU style='font-style:normal'>1.1.2 </span>Особливості
програмування імітаційних моделей</a> </h3>

<p class=MsoNormal>Перша особливість полягає у тому, що для виконання правил
дії паралельно працюючих об’єктів ми створюємо потоки. </p>

<p class=MsoNormal>Базовим класом потоків у мові Java є клас Thread. Але потік
виконання правил дії об’єкту є тільки складовою частиною об’єкту. Диспетчер і
об’єкти, що діють паралельно, можуть існувати і до створення потоку, і після
того, як потік завершився. Тому створювати відповідні класи ми будемо не шляхом
наслідування класу Thread, а шляхом реалізації інтерфейсу Runnable у цих
класах. Як відомо, цей інтерфейс передбачає реалізацію публічного методу run(),
який і є точкою входу до потоку, що створюється.</p>

<p class=MsoNormal>Для того, щоб створити новий потік, клас, який реалізує
Runnable, повинен виконати у одному із своїх методів код, що представлений у
лістингу&nbsp;5.1.</p>

<p class=a1><span style='color:black'>Лістинг 4.1 – Створення потоку для
об’єкту, що реалізує інтерфейс </span>Runnable</p>

<div style='border:solid windowtext 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt'>

<p class=a0CxSpFirst><span style='font-size:13.0pt'>…</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          Thread  thread =
new Thread(this);</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          thread.start();</span></p>

<p class=a0CxSpLast><span style='font-size:13.0pt'>…</span></p>

</div>

<p class=MsoNormal>Щоб призупинити виконання правил дії об’єктів, або
диспетчера будемо використовувати метод wait() класу Object. Для відновлення
виконання правил дії цих об’єктів будемо використовувати метод notify() класу
Object. Слід нагадати, що методи wait() і notify() класу Object не можна
використовувати прямо, викликаючи їх для потоків, якими ми хочемо керувати. Це
можна робити за допомогою деякого іншого, синхронізованого об'єкта з публічним
доступом, що називають монітором. Саме цей об’єкт приймає повідомлення wait() і
notify(). Для породження таких об'єктів і забезпечення їх функціонування у
фреймворці Simulation створено клас process.BooleanSemaphore. </p>

<p class=MsoNormal>Особливість використання потоків при програмуванні
імітаційних моделей полягає також і у тому, що під час роботи моделі не існує
більше одного активного потоку, пов’язаного з роботою моделі. З цієї причини
потоки, що імітують паралельне виконання правил дії об’єктів, називають
псевдопаралельними. Це має місце внаслідок того, що диспетчер, породжуючи або
активізуючи потік виконання правил дії якогось об’єкту, сам призупиняється
доти, поки не призупиниться активізований потік. Таким чином виконується або
потік якогось з об’єктів, або потік диспетчера. Завдяки цьому підтримується
сувора послідовність подій у віртуальному (модельному) часі.</p>

<p class=MsoNormal>Внаслідок псевдопаралельного виконання потоків у імітаційних
моделей практично не існує проблеми використання спільних ресурсів.</p>

<p class=MsoNormal>Ще одна проблема програмування імітаційних моделей полягає в
тому, що об'єкти, які чекають виконання деяких умов, повинні ці умови
пам'ятати. Причому, таких умов у одного об'єкта може бути декілька. У Java ми
можемо оперувати тільки об'єктами, тому умова може бути створена тільки як
метод об'єкта деякого класу. Для створення таких об'єктів доцільно
використовувати функціональний інтерфейс BooleanSupplier, який потребує
реалізації методу getAsBoolean(), що забезпечує перевірку необхідної умови. Для
спрощення коду об’єкт цього типу доцільно створювати за допомогою механізму
лямбда функцій.</p>

<p class=MsoNormal>Таким чином, якщо виникає потреба у передачі або зберіганні
деякої умови, то за допомогою лямбда функції, яка забезпечує перевірку цієї
умови, створюється об’єкт типу BooleanSupplier. Цей об’єкт може бути і
анонімним.</p>

<h3 style='margin-top:12.0pt;margin-right:39.7pt;margin-bottom:3.0pt;
margin-left:73.7pt;text-indent:-36.85pt'><a name="_Toc484953438"></a><a
name="_Toc392262908"><span lang=RU style='font-style:normal'>1.1.3 </span>Класи,
що забезпечують динамічну взаємодію псевдопаралельних процесів</a></h3>

<p class=MsoNormal>Класи фреймворку Simulation, що забезпечують динамічну
взаємодію псевдопаралельних процесів об'єднані у пакеті process.</p>

<p class=MsoNormal>Найважливіші з них, що необхідні для розуміння особливостей
роботи імітаційних моделей розглядаються нижче.</p>

<p class=MsoNormal>Клас BooleanSemaphore використовується для створення
об’єктів, що дозволяють призупиняти і відновлювати потоки виконання правил дії
об’єктів. </p>

<p class=MsoNormal>Клас Actor визначає найбільш загальні властивості й
особливості поведінки об'єктів, які повинні виконувати свої правила дії в часі.</p>

<p class=MsoNormal>Клас Dispatcher описує поведінку і властивості об'єкта, що
забезпечує синхронізацію виконання правил дії компонент моделі, зміну
модельного часу й формування протоколу роботи моделі.</p>

<h4 style='margin-top:12.0pt;margin-right:39.7pt;margin-bottom:3.0pt;
margin-left:3.0cm;text-indent:-45.35pt'><a name="_Toc484953439"></a><a
name="_Toc392262909"></a><a name="_Toc181594828"><span style='font-weight:normal'>1.1.3.1
</span>Клас BooleanSemaphore</a></h4>

<p class=MsoNormal>Об'єкти цього класу використовуються для керування потоками.
Клас має всього одне приватне поле логічного типу з ім'ям value, що може бути
використане як індикатор стану потоку.</p>

<p class=MsoNormal>Для затримки потоків за допомогою об'єктів даного класу
використовується метод waitForValue(boolean), наведений у лістингу 4.2.</p>

<p class=a2>Лістинг 4.2 – Метод waitForValue(boolean)</p>

<div style='border:solid windowtext 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt'>

<p class=a0CxSpFirst><span style='font-size:13.0pt'>public synchronized void
waitForValue(boolean state) {</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>     while (value !=
state) {</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          try     {</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>                            wait();</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>                   } catch
(java.lang.InterruptedException e) {</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>                            e.printStackTrace();</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          }</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>     }</span></p>

<p class=a0CxSpLast><span style='font-size:13.0pt'>}</span></p>

</div>

<p class=MsoNormal>Цей метод використовує стандартний метод wait(), який
забезпечує затримку потоку доти, доки індикатор не перейде в необхідний стан.</p>

<p class=MsoNormal>Для відновлення роботи призупиненого потоку використовується
метод setValue(boolean).</p>

<p class=a2>Лістинг 4.3 –  Метод setValue(boolean)</p>

<div style='border:solid windowtext 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt'>

<p class=a0CxSpFirst><span style='font-size:13.0pt'>     public synchronized
void setValue(boolean newValue) {</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          if (newValue !=
value) {</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>              value =
newValue;</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>              notify();</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          }</span></p>

<p class=a0CxSpLast><span style='font-size:13.0pt'>     }</span></p>

</div>

<p class=MsoNormal>Наведений метод не тільки змінює стан індикатора, але й
сповіщає про це зацікавлений потік за допомогою стандартного повідомлення
notify(), що приводить до поновлення виконання правил дії потоку, який чекав
зміни стану індикатора.</p>

<h4 style='margin-top:12.0pt;margin-right:39.7pt;margin-bottom:3.0pt;
margin-left:3.0cm;text-indent:-45.35pt'><a name="_Toc484953440"></a><a
name="_Toc392262910"></a><a name="_Toc181594830"><span style='font-weight:normal'>1.1.3.2
</span>Клас Actor</a></h4>

<p class=MsoNormal>Цей абстрактний клас містить найбільш загальні властивості й
методи об'єктів, які мають правила дії, розподілені в часі. </p>

<p class=MsoNormal>Клас реалізує два інтерфейси. </p>

<p class=MsoNormal>Інтерфейс Runnable дає можливість виконувати правила дії
об'єктів як потоки. Відповідно до вимог цього інтерфейсу в класі реалізований
метод run(), що забезпечує запуск правил дії об'єктів підкласів.</p>

<p class=MsoNormal>Інтерфейс Clonable дає можливість клонувати об'єкти класу
або його підкласів. Відповідно до вимог цього інтерфейсу в класі реалізований
метод clone(). Особливості клонування об'єктів в Java розглядалися вище, при
розгляді класу MultyActor. </p>

<p class=410><span style='font-size:12.0pt'>Поля об'єктів класу Actor та їх
призначення</span></p>

<p class=MsoNormal>Поле activateCondition зберігає посилання на об'єкт типу
BooleanSupplier, що у вигляді методу getAsBoolean() містить умову, виконання
якої чекає призупинений об'єкт.</p>

<p class=MsoNormal>Поле activateTime, типу double, містить час поновлення
виконання правил дії, призупинених на якийсь час.</p>

<p class=MsoNormal>Поле dispatcher містить посилання на об'єкт класу
Dispatcher, під керуванням якого будуть виконуватися правила дії об'єкта.</p>

<p class=MsoNormal>Поле nameForProtocol містить ім'я об'єкту, що
використовується у протоколі роботи моделі.</p>

<p class=MsoNormal>Поле suspendIndicator містить посилання на об'єкт класу BooleanSemaphore
і використовується для призупинення та відновлення правил дії. </p>

<p class=MsoNormal>Поле waitingTimeHisto призначено для зберігання посилання на
об'єкт класу Histo. Якщо таке посилання передано актору, то у відповідній гістограмі
буде накопичуватися інформація про час чекання актора.</p>

<p class=MsoNormal>Для доступу до полів є методи, названі у відповідності зі
стандартними правилами.</p>

<p class=410 style='margin-right:16.25pt'><a name="_Toc181594831"><span
style='font-size:12.0pt'>Методи, що забезпечують створення потоку виконання
правил дії</span></a></p>

<p class=MsoNormal>Створення та запуск потоку виконання правил дії для об'єктів
класу Actor виконується за допомогою методу start(), що наведений у лістингу 4.4.
Новий потік створюється за допомогою конструктора класу Thread, куди як
параметр передається посилання на «актора», чиї правила дії повинні
виконуватися в цьому потоці. Потоку привласнюється ім'я «актора». Цей метод призначений
для використання тільки об’єктом класу Dispatcher, тому не має публічного
доступу.</p>

<p class=a2>Лістинг 4.4 –  Текст методу start() класу Actor</p>

<div style='border:solid windowtext 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt'>

<p class=a0CxSpFirst><span style='font-size:13.0pt'>     final void start() {</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          // Створюємо і
запускаємо потік виконання правил дії актора</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          Thread thread =
new Thread(this, getNameForProtocol());</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          thread.start();</span></p>

<p class=a0CxSpLast><span style='font-size:13.0pt'>     }</span></p>

</div>

<p class=MsoNormal>Публічний метод з ім'ям run(), є точкою входу потоку
виконання правил дії «актора». Метод реалізований у класі Actor відповідно до
вимог інтерфейсу Runnable. Цей метод, наведений у лістингу 4.5. </p>

<p class=a2>Лістинг 4.5 –  Текст методу run() класу Actor</p>

<div style='border:solid windowtext 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt'>

<p class=a0CxSpFirst><span style='font-size:13.0pt'>     public void run() {</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          dispatcher.printToProtocol(&quot; 
&quot; + nameForProtocol + &quot; стартує&quot;);</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          try {</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>              rule();</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          } catch
(DispatcherFinishException e) {</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>              dispatcher.printToProtocol(&quot; 
&quot; + nameForProtocol </span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>                   +
&quot; не дочекався, бо диспетчер закінчив роботу.&quot;);</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>              return;</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          } finally {</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>              dispatcher.printToProtocol(&quot; 
&quot; + nameForProtocol + &quot; роботу завершив&quot;);</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>              //
Переводимо індикатор у стан &quot;Актора призупинено&quot; і таким чином</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>              //
повідомляємо &quot;Диспетчера&quot;, що виконання правил дії даного
&quot;актора&quot;</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>              //
завершено, що дає можливість &quot;Диспетчеру&quot; продовжити роботу</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>              suspendIndicator.setValue(true);</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          }</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>     }</span></p>

<p class=a0CxSpLast><span style='font-size:13.0pt'>&nbsp;</span></p>

</div>

<p class=MsoNormal>У методі run() викликаються правила дії об'єкта шляхом
звертання до методу rule(). Метод rule() у класі Actor є абстрактним.
Передбачається, що в підкласах цей метод буде реалізований відповідно до правил
дії об’єктів підкласів.</p>

<p class=MsoNormal>Перед викликом правил дії метод run() виводить до протоколу
диспетчера повідомлення про початок роботи об'єкта. Після завершення виконання
правил дії метод виводить до протоколу повідомлення про те, що об'єкт роботу
закінчив. </p>

<p class=MsoNormal>У методі також обробляється виключна ситуація
DispatcherFinishException, яка створюється об’єктами, які не дочекалися
виконання умови, коли диспетчер завершив роботу. </p>

<p class=MsoNormal>Закінчується метод run() викликом методу, що встановлює
індикатору стану потоку значення, яке сигналізує про те, що виконання потоку завершено.
Цей сигнал дозволяє активізувати роботу диспетчера. </p>

<p class=410><a name="_Toc181594832"><span style='font-size:12.0pt'>Методи, що
забезпечують призупинення правил дії об'єктів</span></a></p>

<p class=MsoNormal>Для об'єктів класу Actor передбачено три види зупинок.</p>

<p class=MsoNormal><b>Перший вид зупинки –  це зупинка на якийсь час</b>
(мається на увазі віртуальний модельний час), що за звичай імітує роботу
об'єкта, на виконання якої потрібен певний час. </p>

<p class=MsoNormal>Затримка реалізується за допомогою методу holdForTime(double),
текст якого наведено у лістингу 4.6.</p>

<p class=MsoNormal>У метод передається параметр holdTime, значення якого
дорівнює необхідному часу затримки. </p>

<p class=a2>Лістинг 4.6 –  Текст методу holdForTime(double) класу Actor</p>

<div style='border:solid windowtext 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt'>

<p class=a0CxSpFirst><span style='font-size:13.0pt'>     protected final void
holdForTime(double holdTime) {</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          // Затримка не
має сенсу, якщо диспетчер закінчив роботу.</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          if
(!dispatcher.isActiv()) {</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>              return;</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          }</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          // Обчислюємо
час відновлення правил дії &quot;актора&quot;</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          activateTime =
dispatcher.getCurrentTime() + holdTime;</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          // Заносимо
посилання на &quot;актора&quot;</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          // у список
акторів, що затримані на деякий час.</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          dispatcher.getTimingActorQueue().add(this);</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          dispatcher.printToProtocol(&quot; 
&quot; + getNameForProtocol()</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>                   +
&quot; затриманий до &quot; + activateTime);</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          // Переводимо
індикатор у стан &quot;Актора призупинено&quot;,</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          // внаслідок
чого &quot;Диспетчер&quot; може продовжити  работу. </span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          suspendIndicator.setValue(true);</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          // Призупиняємо
потік виконання правил дії &quot;актора&quot;</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          suspendIndicator.waitForValue(false);</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          // Тут актор
колись відновить виконання правил дії</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          dispatcher.printToProtocol(&quot; 
&quot; + getNameForProtocol()</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>                   +
&quot; активізувався &quot;);</span></p>

<p class=a0CxSpLast><span style='font-size:13.0pt'>     }</span></p>

</div>

<p class=MsoNormal>При виконанні методу, визначається час майбутньої
активізації об'єкта –  activateTime. Значення цього поля встановлюється рівним
сумі поточного значення модельного часу і триалості затримки holdTime. </p>

<p class=MsoNormal>Після цього посилання на об'єкт додається до списку
майбутніх подій диспетчера. </p>

<p class=MsoNormal>Виклик методу suspendIndicator.setValue(true) приводить до
того, що об'єкти, що чекають зміни стану об’єкту, можуть відновити роботу.
Найчастіше таким об'єктом є диспетчер. </p>

<p class=MsoNormal>Виклик методу suspendIndicator.waitForValue(false) приводить
до призупинення правил дії об'єкта.</p>

<p class=MsoNormal><b>Другий вид зупинки виконання правил дії –  це затримка до
виконання деякої умови.</b> Така затримка реалізується за допомогою методу
waitForCondition(BooleanSupplier, String).</p>

<p class=MsoNormal>Першим параметром методу є об'єкт інтерфейсного типу
BooleanSupplier. Цей інтерфейс передбачає реалізацію методу getAsBoolean(), що
забезпечує перевірку необхідної умови. Таким чином, у метод waitForCondition()
передається не сама умова (що в Java неможливо), а об'єкт класу, через який
можна викликати метод перевірки цієї умови. </p>

<p class=MsoNormal>Другим параметром методу є рядок символів, що
використовується для ідентифікації умови у протоколі.</p>

<p class=a2>Лістинг 4.7 –  Метод waitForCondition(BooleanSupplier, String)
класу Actor<span style='font-size:10.0pt;font-family:"Courier New";color:black;
background:white'> </span></p>

<div style='border:solid windowtext 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt'>

<p class=a0CxSpFirst><span style='font-size:13.0pt'>     protected final void
waitForCondition(BooleanSupplier c, String s)</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>              throws
DispatcherFinishException {</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          // Якщо умова
виконується, затримка не потрібна</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          if (c.
getAsBoolean() )</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>              return;</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          // Якщо
диспетчер закінчив роботу, затримка не має сенсу.</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          if
(!getDispatcher().getThread().isAlive()) {</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>              return;</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          }</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          // Зберігаємо
об’єкт, що містить умову.</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          activateCondition
= c;</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          // Передаємо
&quot;актора&quot; до списку акторів</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          // що затримані
до виконання умови</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          getDispatcher().getWaitingActorQueue().add(this);</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          getDispatcher().printToProtocol(</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>                   &quot; 
&quot; + getNameForProtocol() + &quot; чекає '&quot;+ s + &quot;'&quot;);</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          //Запам'ятовуємо
час, коли почалося чекання</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          double
stopTime=dispatcher.getCurrentTime();</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          // Переводимо
індикатор у стан &quot;Актора призупинено&quot;,</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          // надаючи 
&quot;Диспетчеру&quot; можливість працювати </span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          suspendIndicator.setValue(true);</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          // Переводимо
потік виконання правил дії &quot;актора&quot;</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          // у стан
чекання.</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          // Коли умова
виконується,</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          // диспетчер
перемикає індикатор у стан false</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          suspendIndicator.waitForValue(false);</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          if(waitingTimeHisto!=null)</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>              //Обчислюємо
і передаємо до гістограми час чекання</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>              waitingTimeHisto.add(dispatcher.getCurrentTime()-stopTime);</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          if
(activateCondition. getAsBoolean())</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>              getDispatcher().printToProtocol(</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>                        &quot; 
&quot; + getNameForProtocol() + &quot; дочекався '&quot;+ s + &quot;'&quot;);</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          else</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>              throw new
DispatcherFinishException();</span></p>

<p class=a0CxSpLast><span style='font-size:13.0pt'>     }</span></p>

</div>

<p class=MsoNormal>При виконанні методу waitForCondition() перш за все буде
проводитись перевірка умови за допомогою виклику методу c. getAsBoolean(). Якщо
умова виконується, то робота методу закінчується. Якщо ж умова не виконується,
то посилання на об'єкт типу BooleanSupplier заноситься в поле activateCondition
«актора», а посилання на самого «актора» передається диспетчерові. </p>

<p class=MsoNormal>Виклик методу suspendIndicator.setValue(true) приводить до
того, що об'єкти, що чекають цього перемикання, можуть відновити роботу.
Частіше за все  таким об'єктом є диспетчер. </p>

<p class=MsoNormal>Виклик методу suspendIndicator.waitForValue(false) приводить
до припинення правил дії об'єкта.</p>

<p class=MsoNormal>Особливість виконання цього методу полягає у тому, що умова,
на виконання якої очікує актор, можливо не буде виконана до закінчення роботи
диспетчера. У цьому випадку диспетчер перед закінченням роботи примусово
активізує потік незважаючи на невиконання умови. Для того, щоб цей випадок можна
було б належним чином обробити, метод викликає виключну ситуацію
DispatcherFinishException, яка має бути опрацьована у правилах дії об’єкту. Фактично
вона полягає у припиненні правил дії (return).</p>

<p class=MsoNormal>Третій вид зупинки виконання правил дії – це затримка до
виконання деякої умови але не довше, ніж на визначений час. Така затримка
реалізується за допомогою методу waitForConditionOrHoldForTime(BooleanSupplier,
String, double), або методу holdForTimeOrWaitForCondition (double,
BooleanSupplier, String,). Методи дуже схожі на обидва попередні методи.
Різниця полягає тільки у тому, що посилання на актора розміщується у обох
списках диспетчера і тому продовження правил дії відновляється або після
виконання умови, або у призначений час. Наводити текст цього методу тут не
будемо</p>

<h4 style='margin-top:12.0pt;margin-right:39.7pt;margin-bottom:3.0pt;
margin-left:3.0cm;text-indent:-45.35pt'><a name="_Toc484953441"></a><a
name="_Toc392262911"></a><a name="_Toc181594834"><span style='font-weight:normal'>1.1.3.3
</span>Клас Dispatcher</a></h4>

<p class=MsoNormal>Головне призначення цього класу – керувати модельним часом і
забезпечити синхронізацію виконання правил дії «акторів». Крім того диспетчер
формує протокол роботи «акторів», що істотно спрощує налагодження<span
style='color:red'> </span>застосувань. </p>

<p class=MsoNormal>Поля об'єктів цього класу мають таке призначення:</p>

<p class=MsoNormal>currentTime –  поточне значення модельного часу.</p>

<p class=MsoNormal>startList – список об'єктів, правила дії яких диспетчер
повинен активізувати. На початку роботи цей список повинен містити посилання
хоча б на один об'єкт, яким повинен керувати диспетчер. Поповнення цього списку
можливо за допомогою методу addStartingActor(Actor).</p>

<p class=MsoNormal>timingActorQueue –  список майбутніх подій, де перебувають
посилання на об'єкти, правила дії яких припинені на деякий час. На початку
цього списку має бути актор з найменшим часом поновлення правил дії. Це
забезпечується об’єктом типу Comparator, який порівнює час активізації акторів.</p>

<p class=MsoNormal>waitingActorQueue –  список посилань на об'єкти, у яких
правила дії припинені до виконання деяких умов. Об'єкти в цьому списку
впорядковані по правилу FIFO.</p>

<p class=MsoNormal>protocolFileName –  рядок, що визначає ім'я файлу, куди буде
виводиться протокол роботи моделі. Якщо ця змінна має значення “Console”,
протокол виводиться на консоль. Якщо значення цієї змінної пустий рядок,
протокол не виводиться.</p>

<p class=MsoNormal>thread – посилання на потік виконання правил дії диспетчера.</p>

<p class=MsoNormal>active –  поле логічного типу, що має значення true, поки
диспетчер працює. Перед закінченням роботи «диспетчер» установлює значення поля
рівним false. </p>

<p class=MsoNormal>dispatcherStartListeners, changeTimeListeners,
dispatcherFinishListeners –  це колекції, що зберігають посилання на слухачів
подій, які генерує диспетчер під час своєї роботи. Подія dispatcherStartEvent
сповіщає слухачів про початок роботи диспетчера. Подія changeTimeEvent сповіщає
слухачів про зміну модельного часу. Подія dispatcherFinishEvent сповіщає
слухачів про завершення роботи диспетчера.</p>

<p class=410><a name="_Toc181594836">Робота диспетчера</a></p>

<p class=MsoNormal>Диспетчер, так само як і «актори», має свої правила дії. Ці
правила дії виконуються в окремому потоці, що вимагає реалізації інтерфейсу
Runnable у класі Dispatcher і наявності в ньому методу run.</p>

<p class=MsoNormal>Запуск диспетчера відбувається шляхом виклику публічного
методу start() класу Dispatcher.  Виклик цього методу означає початок процесу
моделювання. Текст методу наведений у лістингу 4.9. </p>

<p class=a2>Лістинг 4.9 –  Метод start() класу Dispatcher</p>

<div style='border:solid windowtext 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt'>

<p class=a0CxSpFirst><span style='font-size:13.0pt'>     public void start() {</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          if
(protocolFileName != null &amp;&amp; protocolFileName != &quot;Console&quot;</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>                   &amp;&amp;
protocolFileName.trim() != &quot;&quot;) {</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>              FileWriter
file;</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>              try {</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>                   file =
new FileWriter(protocolFileName, false);</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>                   file.close();</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>              } catch
(java.io.IOException e) {</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>                   System.out.println(&quot;Не
вийшло відкрити файл протоколу&quot;);</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>              }</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          }</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          this.thread= new
Thread(this, &quot;Dispatcher&quot;);;</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          this.thread.start();</span></p>

<p class=a0CxSpLast><span style='font-size:13.0pt'>     }</span></p>

</div>

<p class=MsoNormal>У цьому методі спочатку, при необхідності, створюється файл
для виводу протоколу роботи моделі. Далі створюється потік виконання правил дії
диспетчера й запускається за допомогою методу start() потоку, який ініціює
виконання методу run() диспетчера. Код методу  run() наведений у лістингу 4.10</p>

<p class=a2>Лістинг 4.10 –  Правила дії об'єкта класу Dispatcher</p>

<div style='border:solid windowtext 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt'>

<p class=a0CxSpFirst><span style='font-size:13.0pt'>public void run() {</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>      activ = true;</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>     currentTime = 0;</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>      printToProtocol(&quot;Час
&quot; + currentTime);</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>     Actor
readyActor=null;</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>      while (true) {</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          runStartList();</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          readyActor =
testWaitingQueue();</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          if (readyActor
== null) {</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>              if (timingActorQueue.isEmpty())
{</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>                   break;</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>              }</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>              readyActor =
timingActorQueue.remove();                                                                                setCurrentTime(readyActor.getActivateTime());</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          }</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          readyActor.getSuspendIndicator().setValue(false);</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          readyActor.getSuspendIndicator().waitForValue(true);</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>     }</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>     activ = false;</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>     releaseWaitingQueue();</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>     fireDispatcherFinishEvent(new
DispatcherFinishEvent(this));</span></p>

<p class=a0CxSpLast><span style='font-size:13.0pt'>}</span></p>

</div>

<p class=MsoNormal>Робота диспетчера починається з ініціалізації полів activ та
currentTime. Далі виконується циклу правил дії «диспетчера». </p>

<p class=MsoNormal>Починається цей цикл викликом методу runStartList(), що
створює потоки виконання правил дії «акторів», занесених у стартовий список.
Текст цього методу наведений у лістингу 4.11.</p>

<p class=a2>Лістинг 4.11 –  Метод runStartList() класу Dispatcher</p>

<div style='border:solid windowtext 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt'>

<p class=a0CxSpFirst><span style='font-size:13.0pt'>     private void
runStartList() {</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          while
(!startList.isEmpty()) {</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>              Actor a =
startList.remove(0);</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>              a.getSuspendIndicator().setValue(false);</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>              a.start();</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>              a.getSuspendIndicator().waitForValue(true);</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          }</span></p>

<p class=a0CxSpLast><span style='font-size:13.0pt'>     }</span></p>

</div>

<p class=MsoNormal>Правила дії «акторів», що стартують, виконуються по черзі.
Новий потік стартує тільки після того, як буде призупинений попередній. Такий
порядок забезпечує об’єкт класу BooleanSemaphore, який знаходиться у полі
suspendIndicator класу Actor. Коли правила дії чергового «актора» припиняються,
цикл активізації акторів продовжується і стартує новий актор. Виконання методу
закінчується тільки тоді, коли правила дії останнього «актора», що стартує,
будуть призупинені. </p>

<p class=MsoNormal>Після виконання методу runStartList() посилання на «акторів»
потрапляють або у список майбутніх подій timingActorQueue, або в список
waitingActorQueue, де знаходяться об'єкти, що чекають виконання умов. На цьому
завершується перший етапу циклу правил дії диспетчера.</p>

<p class=MsoNormal>Наступні етапи циклу робота «диспетчера» полягають у обробці
списків timingActorQueue та waitingActorQueue.</p>

<p class=MsoNormal>Насамперед, аналізується список об'єктів, що чекають
виконання умов. Для цього використовується метод testWaitingQueue().</p>

<p class=a2 style='text-align:justify'>Лістинг 4.12 –  Метод testWaitingQueue()
для обробки списку об'єктів, що чекають виконання умов</p>

<div style='border:solid windowtext 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt'>

<p class=a0CxSpFirst><span style='font-size:13.0pt'>     private Actor
testWaitingQueue() {</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          Iterator i =
this.waitingActorQueue.iterator();</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          while
(i.hasNext()) {</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>              Actor a =
i.next();</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>              if
(a.activateCondition.getAsBoolean()) {</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>                   waitingActorQueue.remove(a);</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>                   timingActorQueue.remove(a);</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>                   return
a;</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>              }</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          }</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          return null;</span></p>

<p class=a0CxSpLast><span style='font-size:13.0pt'>     }</span></p>

</div>

<p class=MsoNormal>Метод забезпечує послідовний перегляд списку «акторів», що
чекають виконання умов, і перевірку очікуваної умови для кожного з них.
Нагадаємо, що в полі activateCondition акторів зберігаються посилання на об'єкт
класу, що реалізує метод getAsBoolean(), відповідно до вимог  інтерфейсу
BooleanSupplier. Саме метод  getAsBoolean() перевіряє необхідну умову.</p>

<p class=MsoNormal>Якщо умова, що перевіряється, виконується для якогось
«актора», то цей «актор» вилучається зі списку і повертається, як результат
виконання методу. Посилання на цього актора вилучається також і із списку
майбутніх подій, якщо воно там є. У випадку коли актор, для якого виконалась
очікувана подія, не знайдений, метод повертає null. Результат виконання методу
привласнюється змінній readyActor. </p>

<p class=MsoNormal>Наступний етап основного циклу роботи диспетчера виконується
в тому випадку, якщо значення змінної readyActor дорівнює null. На цьому етапі
диспетчер працює зі списком «акторів», правила дії яких призупинені на якийсь
час. Якщо цей список порожній, то диспетчер закінчує свою роботу. Обробка не
порожнього списку полягає в тім, що із списку вилучається «актор» з мінімальним
часом активізації. Посилання на цей об'єкт записується в змінну readyActor
Модельному часу currentTime привласнюється значення часу активізації об'єкта
readyActor, що зберігається в змінній activateTime. Тобто диспетчер, побачивши,
яким повинен бути час найближчої події, таким його й встановлює. Для зміни
модельного часу викликається метод setCurrentTime, що забезпечує вивід рядка
протоколу з новим значенням часу. Крім того, у методі setCurrentTime
створюється подія ChangeTimeEvent, яка може бути використана іншими об'єктами,
наприклад, для індикації поточного часу або збору статистичної інформації про
роботу об'єкта. </p>

<p class=MsoNormal>На завершальному етапі виконання циклу змінюється стан
індикатора «актора» readyObject, внаслідок чого виконання правил дії «актора»
може відновитися. А для того, щоб це дійсно відбулося, робота диспетчера
припиняється за допомогою індикатора того «актора», чиї правила дії
відновляються, шляхом виклику методу readyActor.getSuspendIndicator().
waitForValue(true).</p>

<p class=MsoNormal>Робота диспетчера буде відновлена тільки після того як
правила дії активізованого «актора» призупиняться або закінчяться. </p>

<p class=MsoNormal>Цикл виконання правил дії диспетчера триває доти, поки
список timingActorQueue не стане порожнім, що свідчить про зупинку модельного
часу.</p>

<p class=MsoNormal>Після завершення циклу правил дії диспетчера виконуються
операції, що завершують роботу диспетчера. </p>

<p class=MsoNormal>Насамперед, у поле active заноситься значення false. Після
цього викликається метод releaseWaitingQueue().</p>

<p class=a2>Лістинг 4.13 –  Метод releaseWaitingQueue(), що звільняє списки
об'єктів, що чекають виконання умов</p>

<div style='border:solid windowtext 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt'>

<p class=a0CxSpFirst><span style='font-size:13.0pt'>private void
releaseWaitingQueue() {</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          printToProtocol(&quot; 
Диспетчер звільняє потоки, </span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>                                               що
чекають виконання умови&quot;);</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          while
(waitingActorQueue.size()&gt;0) {</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>               Actor a =
waitingActorQueue.remove(0);</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>               a.getSuspendIndicator().setValue(false);</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>               //Будемо
чекати, поки не завершиться виконання правил дії</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>               a.getSuspendIndicator().waitForValue(true);</span></p>

<p class=a0CxSpMiddle><span style='font-size:13.0pt'>          }</span></p>

<p class=a0CxSpLast><span style='font-size:13.0pt'>}</span></p>

</div>

<p class=MsoNormal><a name="_Toc122606326">Цей метод послідовно активізує
правила дії «акторів», які чекають виконання умов, але вже не дочекаються
цього. Передбачається, що після виходу з режиму очікування «актор» завершить
свої правила дії, обробивши виключну ситуацію DispatcherFinishExeption.</a></p>

<p class=MsoNormal>Такий «дивний» спосіб пов'язаний з тим, що в Java неможливо
переривати виконання потоку зовні. Потік повинен сам завершувати свою роботу.</p>

<p class=MsoNormal>Після виконання завершальних операцій диспетчер формує подію
DispatcherFinishEvent, що сповіщає всіх зацікавлених слухачів про завершення
роботи диспетчера.</p>

<p class=MsoNormal><span lang=RU>&nbsp;</span></p>

</div>

</body>

</html>
