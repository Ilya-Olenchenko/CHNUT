/* Generated by Together */

package net.soft_systems.crypto.frames;
import java.awt.Rectangle;
import java.util.*;
import net.soft_systems.crypto.Run;
import net.soft_systems.crypto.beans.process.*;
import net.soft_systems.integrator.*;
/**
 * Panel where painting of beans is performed. It must be placed into
 * Scrollpane in order to be scrollable because StructureCanvas changes it's
 * size according to placement of beans. Beans can be moved in the canvas, double clicked.
 */
public class ProcessesCanvas extends CryptoCanvas {
	protected Vector getBeanRelations(Bean b) {
		if (ProcessBean.class.isAssignableFrom(b.getClass())) {
			ProcessBean processBean = (ProcessBean)b;
			Vector nodes            = processBean.getNodes();
			Enumeration en          = nodes.elements();
			NodeBean nodeBean;
			Vector allRelations = new Vector();
			Vector relations;
			while (en.hasMoreElements()) {
				nodeBean = (NodeBean)en.nextElement();
				relations = Run.infoSystem.getChannelWith(nodeBean);
				allRelations.addAll(relations);
			}
			return allRelations;
		}
		else if (NodeBean.class.isAssignableFrom(b.getClass())) {
			return Run.infoSystem.getChannelWith((NodeBean)b);
		}
		else { return new Vector(); }
	}
	/**
	 * @return Vector containing vectors of beans which can be selected on the canvas. Order of selection is
	 * the same as order of vectors
	 */
	public Vector getSelectBeansVectors() {
		Vector beans = new Vector();
		beans.add(Run.infoSystem.getChannels());
		beans.add(Run.infoSystem.getProcesses());
		return beans;
	}
	public Vector getBeansVectors() {
		Vector beans = new Vector();
		beans.add(Run.infoSystem.getChannels());
		beans.add(Run.infoSystem.getProcesses());
		return beans;
	}
	/**
	 * Must return relation bean which includes <code>draggedBean</code>
	 * @return instance of relation bean with bean <code>draggedBean</code>
	 */
	protected RenderableBean isRelationSource(RenderableBean draggedBean) {
		if (NodeBean.class.isAssignableFrom(draggedBean.getClass())) {
			NodeBean node = (NodeBean)draggedBean;
			if (node.getNodeType() == NodeBean.OUT) {
				ChannelBean channel = Run.infoSystem.getChannelFrom(node);
				if (channel == null) { channel = new ChannelBean(node); }
				return channel;
			}
			else { return null; }
		}
		else { return null; }
	}
	/**
	 * Must return true if bean <code>nextBean</code> can be included in relation <code>relation</code>
	 * and add that bean to the ralation
	 * @return true if bean <code>nextBean</code> can be included in relation <code>relation</code>.
	 */
	protected boolean tryAddToRelation(RenderableBean relation, RenderableBean nextBean) {
		if (ChannelBean.class.isAssignableFrom(relation.getClass()) &&
			(NodeBean.class.isAssignableFrom(nextBean.getClass()))) {
				NodeBean node = (NodeBean)nextBean;
				if (node.getNodeType() == NodeBean.IN) {
					ChannelBean channel = (ChannelBean)relation;
					if (channel.addDstNode(node)) {
						if (!Run.infoSystem.getChannels().contains(channel)) {
							Run.integrator.addBean(channel, Run.infoSystem.getChannelTopic(), false);
						}
						return true;
					}
					else { return false; }
				}
				else { return false; }
		}
		else { return false; }
	}
	/**
	 * Invoked when user pressed delete button. Removes selected channels
	 * @param selectedBeans Beans which are selected
	 */
	public void tryDeleteSelected(Vector beans) {
		Enumeration en = beans.elements();
		Bean bean;
		Vector toRemove = new Vector();
		while (en.hasMoreElements()) {
			bean = (Bean)en.nextElement();
			if (ChannelBean.class.isAssignableFrom(bean.getClass())) {
				ChannelBean channel = (ChannelBean)bean;
				Debug.debug("To delete channel with src " + channel.getSrcNode());
				toRemove.add(bean);
			}
		}
		en = toRemove.elements();
		Bean channelGroup = Run.infoSystem.getChannelTopic();
		Rectangle repaintRect = null;
		while (en.hasMoreElements()) {
			bean = (Bean)en.nextElement();
			selectedBeans.remove(bean);
			if (repaintRect == null) { repaintRect = getBeanShape(bean); }
			else { repaintRect.add(getBeanShape(bean)); }
			//Run.infoSystem.getChannels().remove(bean);
			Run.integrator.delBean(bean, channelGroup, false);
		}
		if (repaintRect != null) { repaint(repaintRect); }
	}
}

